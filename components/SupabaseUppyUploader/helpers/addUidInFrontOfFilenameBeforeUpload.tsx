import Uppy from '@uppy/core';
import { v4 as uuid } from 'uuid';

export default function addUidInFrontOfFilename(uppy: Uppy) {

  uppy.setOptions({
    onBeforeFileAdded: (newFile) => {

      /*When specified, add a UID to the front of our filename

      To make this work, we have to rename the file.name, file.meta.name (for self-explanatory reasons)
      
      We also need to override the default uppy-generated file.id with our own file.id
      Reason: Uppy generates it's own file.id based on the file name & a few other things
      This leads to the exact same file.id each time, if loading the exact same file from same source
      Uppy.Tus plugin uses file.id (which is usually the uppy-generated one) to identify the file on the server
      If the user uploads a file (filename.jpg), then refreshes, and later uploads the same file (filename.jpg) 
      from a new Uppy instance the existing file will be resumed (even if already finished)
      rather than a new being created on the server
      This is usually desirable behaviour, allowing resumable uploads and avoiding duplicate files or filepath conflicts
      however when we are adding our own ID to the file name before upload, this causes problems because Uppy's ID is generated
      based on the original file name not the modified one with the uid in front of it, causing differently named files to be treated as identical
      and therefore not being uploaded again, and being reported by Uppy as the worng filePath

      Here's how that arises
      1. User uploads file1.jpg via Uppy & Tus. 
        We auto-set the filename to uid1_file1.jpg, but file.id generated by uppy is unchanged.
      2. This file is uploaded to Supabase Storage, identified by the Uppy-generated ID, and stored as uid1_file1.jpg. The file upload finishes.
        Uppy reports that the successfuly uploaded file is stored at somebucket/uid1_file1.jpg (all OK so far)
      3. User refreshes the page with Uppy on it
      4. User selects file1.jpg again. We auto-set the filename, this time to uid2_file1.jpg, but the uppy generated file.id is the same as in (1)
      5. Uppy identifies the file by it's uppy-generated ID to Supabase Storage. Supabase storage sees the file is already there and
        reports that upload is complete (since it previously did) and does NOT return the filename uid1_file1.jpg
        Uppy reports that the file has finished, and thinks it's path is somebucket/uid2_file1.jpg (INCORRECT!)
        Supabase storage does not return the filepath, so we have no way of overriding what Uppy reports as the successfully uploaded filepath
      7. If we store uid2_file1.jpg and later try to run an API call to download it, the API call will fail, 
        because the file is actually stored as uid1_file1.jpg!
      
      Furthermore, if we are adding uid to filenames, we're expecting to ALLOW 2x identical files to be uploaded without conflict,
      and that clearly isn't happening here

      To fix these issues, we override the file.id generated by Uppy with our own ID, and store the original Uppy-generated ID in file.meta
      Here's the scenario again

      Here's how that arises
      1. User uploads file1.jpg via Uppy & Tus. 
        We auto-set the filename to uid1_file1.jpg, and file.id to uid1.
      2. This file is uploaded to Supabase Storage, identified by id uid1, and stored as uid1_file1.jpg. The file upload finishes.
        Uppy reports that the successfuly uploaded file is stored at somebucket/uid1_file1.jpg (all OK so far)
      3. User refreshes the page with Uppy on it
      4. User selects file1.jpg again. We auto-set the filename, this time to uid2_file1.jpg, and id to uid2.
      5. When upload starts, Supabase Storage sees that there's no file with id uid2 so a new upload starts, then finishes
        Uppy reports that the successfuly uploaded file is stored at somebucket/uid2_file1.jpg (GOOD)
        We also have two versions of the file stored on the server without conflict: uid1_file1.jpg and uid2_file1.jpg (GOOD)
      
      
      This is good, but one problem remains:
      Uppy prevents the user selecting identical files in THE SAME Uppy instance by it's file.id, which is desirble
      Eg 
      1. User opens a page with Uppy on it
      2. They select file1.jpg and it's added to the Uppy queue
      3. They "add more files" and select file1.jpg AGAIN
      The expected behaviour is that file1.jpg will NOT be added to the queue twice, because Uppy sees that the file.id is the same
      This works well by default, until we start messing with the file.id
      In order to prevent the user adding the same file to an Uppy instance twice, we store the original Uppy-generated ID in file.meta and run a custom
      check beforeFileUpload to prevent adding the same file twice
      */
      
      //Generate a custom ID
      const customId = uuid();

      //Extract the original uppy-generated ID from the file
      const originalIdFromUppy = newFile.id;

      //Check if the file is already in THIS uppy instance. Prevent adding if it is
      const identicalFileAlreadyInUppy = uppy.getFiles().some(file => file.meta.originalIdFromUppy === originalIdFromUppy);
      if(identicalFileAlreadyInUppy){
        uppy.info('You have already added this file, so we skipped it. If you need to re-upload the file, remove it first then try again.', 'error', 3000);
        return false;
      } 

      //Modify the file:
      //Sub our ID in as file.id, and add our id to the filename, and store original ID in file.meta
      //Return the modified file to Uppy for processing
      const modifiedFile = {
        ...newFile,
        id: customId,
        name: `${customId}_${newFile.name}`,
        meta: {
          ...newFile.meta,
          name: `${customId}_${newFile.meta.name}`,
          originalIdFromUppy,
        }
      }
      return modifiedFile;
    }
  })
}